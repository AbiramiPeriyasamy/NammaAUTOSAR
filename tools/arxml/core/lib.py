#
# Created on Mon Aug 15 2022 1:49:18 PM
#
# The MIT License (MIT)
# Copyright (c) 2022 Aananth C N
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software
# and associated documentation files (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial
# portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
import os
import sys
import xml.etree.ElementTree as ET

from datetime import datetime

###############################################################################
# Common ARXML specific routines are placed here.


#####################################
# Export Functions
#####################################

def finalize_arxml_doc(file):
   with open(file, "r") as f:
      contents = f.readlines()
   comment = "<!-- Generated by OSEK Builder tool of FreeOSEK project on " + str(datetime.now()) + " -->\n"
   contents.insert(1, comment)
   with open(file, "w") as f:
      contents = "".join(contents)
      f.write(contents)



def insert_container(root, name, type, dref):
   ctnr = ET.SubElement(root, "ECUC-CONTAINER-VALUE")
   shortname = ET.SubElement(ctnr, "SHORT-NAME")
   shortname.text = name
   if type == "conf":
      def_ref = ET.SubElement(ctnr, "DEFINITION-REF", DEST="ECUC-PARAM-CONF-CONTAINER-DEF")
   elif type == "choice":
      def_ref = ET.SubElement(ctnr, "DEFINITION-REF", DEST="ECUC-CHOICE-CONTAINER-DEF")
   else:
      def_ref = ET.SubElement(ctnr, "DEFINITION-REF", DEST="ERROR-INVALID_TYPE")
   def_ref.text = dref
   return ctnr



def insert_reference(root, dref, vref):
   rctnr = ET.SubElement(root, "ECUC-REFERENCE-VALUE")
   def_ref = ET.SubElement(rctnr, "DEFINITION-REF", DEST="ECUC-REFERENCE-DEF")
   def_ref.text = dref
   val_ref = ET.SubElement(rctnr, "VALUE-REF", DEST="ECUC-CONTAINER-VALUE")
   val_ref.text = vref
   return rctnr



def insert_param(root, refname, type, subtype, value):
   if type == "text":
      param_blk = ET.SubElement(root, "ECUC-TEXTUAL-PARAM-VALUE")
   elif type == "numerical":
      param_blk = ET.SubElement(root, "ECUC-NUMERICAL-PARAM-VALUE")
   else:
      param_blk = ET.SubElement(root, "ECUC-ERROR_UNDEFINED-PARAM-VALUE")


   if subtype == "bool":
      def_ref = ET.SubElement(param_blk, "DEFINITION-REF", DEST="ECUC-BOOLEAN-PARAM-DEF")
   elif subtype == "int":
      def_ref = ET.SubElement(param_blk, "DEFINITION-REF", DEST="ECUC-INTEGER-PARAM-DEF")
   elif subtype == "func":
      def_ref = ET.SubElement(param_blk, "DEFINITION-REF", DEST="ECUC-FUNCTION-NAME-DEF")
   elif subtype == "enum":
      def_ref = ET.SubElement(param_blk, "DEFINITION-REF", DEST="ECUC-ENUMERATION-PARAM-DEF")
   else:
      def_ref = ET.SubElement(param_blk, "DEFINITION-REF", DEST="ECUC-ERROR_UNDEFINED-PARAM-DEF")
   def_ref.text = refname

   def_ref = ET.SubElement(param_blk, "VALUE")
   def_ref.text = value




#####################################
# Import Functions
#####################################
def tag_uri_and_name(elem):
    if elem.tag[0] == "{":
        uri, ignore, tag = elem.tag[1:].partition("}")
    else:
        uri = None
        tag = elem.tag
    return uri, tag


def get_tag(elem):
   uri, tag = tag_uri_and_name(elem)
   return tag


def get_param(elem):
   tag = val = None
   for item in list(elem):
      if get_tag(item) == "DEFINITION-REF":
         tag = str(item.text).split("/")[-1]
      if get_tag(item) == "VALUE":
         val = item.text
   return tag, val



def get_param_list(ctnr):
   plist = []
   for elem in list(ctnr):
      if get_tag(elem) == "PARAMETER-VALUES":
         for param in list(elem):
            if get_tag(param)[-11:] == "PARAM-VALUE":
               tag, val = get_param(param)
               item = { "tag":tag, "val":val }
               plist.append(item)
   return plist



def get_dref_from_container(ctnr):
   dref = None
   for elem in list(ctnr):
      if get_tag(elem) == "DEFINITION-REF":
         dref = elem.text
         break
   return dref



def get_dref_list(ctnr):
   plist = []
   tag = val = None
   for elem in list(ctnr):
      if get_tag(elem) == "ECUC-REFERENCE-VALUE":
         for ref in list(elem):
            if get_tag(ref) == "DEFINITION-REF":
               tag = str(ref.text).split("/")[-1]
            if get_tag(ref) == "VALUE-REF":
               val = str(ref.text).split("/")[-1]
         item = { "tag":tag, "val":val }
         plist.append(item)
   return plist


#####################################
# Search Functions
#####################################
def find_ar_package(shortname, ar_file):
   tree = ET.parse(ar_file)
   root = tree.getroot()
   ar_pkg = None

   if get_tag(root) == "AUTOSAR":
      for item in list(root):
         if get_tag(item) == "AR-PACKAGES":
            for pkg in list(item):
               if get_tag(pkg) == "AR-PACKAGE":
                  for elem in list(pkg):
                     if get_tag(elem) == "SHORT-NAME":
                        if elem.text == shortname:
                           ar_pkg = pkg
                           break
   return ar_pkg


def find_modconf(shortname, root):
   modconf = None
   
   if get_tag(root) == "ELEMENTS":
      for elem in list(root):
         if get_tag(root) == "ECUC-MODULE-CONFIGURATION-VALUES":
            for item in list(elem):
               if get_tag(item) == "SHORT-NAME":
                  if item.text == shortname:
                     modconf = item
                     break
                  
   return modconf
               