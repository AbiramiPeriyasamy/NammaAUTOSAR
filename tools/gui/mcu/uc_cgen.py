#
# Created on Sat Aug 13 2022 10:19:54 PM
#
# The MIT License (MIT)
# Copyright (c) 2022 Aananth C N
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this software
# and associated documentation files (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies or substantial
# portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
# TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
import os
import json

import arxml.mcu.arxml_mcu as arxml_mcu
import utils.search as search



def generate_platform_header(gui):
    cwd = os.getcwd()
    board_path = search.find_dir("bsp", cwd+"/submodules/MCAL/Mcu")
    platform_h = open(board_path+"/platform.h", "w")
    platform_h.write("#ifndef NAMMA_AUTOSAR_PLATFORM_H\n")
    platform_h.write("#define NAMMA_AUTOSAR_PLATFORM_H\n\n")
    platform_h.write("/* This file is autogenerated by NammaAUTOSAR builder */\n\n")
    platform_h.write("#include <"+gui.uc_info.micro+".h>\n")
    platform_h.write("#include <platform_"+gui.uc_info.micro+".h>\n")
    platform_h.write("\n\n#endif\n")
    platform_h.close()



# This function creates app_paths.mk by reading applications.json file
# The app_paths.mk will be included by main Makefile to build all apps
def generate_make_list_for_apps(cwd):
    app_layer_path = cwd+"/submodules/AL/"
    apps_json_file = app_layer_path+"/applications.json"
    app_data = None
    with open(apps_json_file) as jfile:
        app_data = json.load(jfile)
    jfile.close()

    app_paths_mk = cwd+"/app_paths.mk"
    with open(app_paths_mk, "w") as apfile:
        apfile.write("# This file is autogenerated, any hand modifications will be lost!\n\n")
        components = []

        # parse all application entries in jsone file
        for app in app_data:
            app_name = app["git"].split("/")[-1].split(".git")[0]
            components.append(app_name)
            app_path = search.find_dir(app_name, cwd+"/submodules")
            apfile.write(app_name+"_path := "+app_path)

        # create a dependency list for main makefile to invoke it
        apfile.write("\n\nAPP_LIST := ")
        for app_name in components:
            apfile.write(" $("+app_name+"_path)")
        apfile.write("\n\n")
        apfile.close()



# This function creates c_l_flags.mk based on the micro and board selected.
# The c_l_flags.mk will be included by main Makefile to provide target specific
# CFLAGS and LDFLAGS to all other makefiles.
def generate_c_l_flags_file(gui, cwd):
    micro_file = search.find_file(gui.uc_info.micro+".mk", cwd)
    micro_path = micro_file.split(gui.uc_info.micro+".mk")[0]
    u_c_l_file = micro_path+"c_l_flags.mk"

    if os.path.exists(u_c_l_file):
        c_l_flags_mk = cwd+"/c_l_flags.mk"
        with open(c_l_flags_mk, "w") as clfile:
            clfile.write("# This file is autogenerated, any hand modifications will be lost!\n\n")
            clfile.write("include "+micro_path+"c_l_flags.mk\n")
            clfile.close()
    else:
        print("Error: File \"c_l_flags.mk\" is not found in "+micro_path+"!")
        print("Hints:  Please add it and define CFLAGS and LDFLAGS in it for the uC.")



# returns non-zero in case of error
def create_source(gui):
    cwd = os.getcwd()
    paths_mk = open(cwd+"/path_defs.mk", "w")
    incls_mk = open(cwd+"/includes.mk", "w")

    # PATH variables
    paths_mk.write("# Definitions\n")
    paths_mk.write("CWD := "+cwd+"\n")
    paths_mk.write("ROOT_PATH := "+cwd+"\n")

    mcu_path = search.find_dir("Mcu", cwd+"/submodules")
    paths_mk.write("MCU_PATH := "+mcu_path+"\n")
    
    mcu_board_path = search.find_dir("bsp", cwd+"/submodules/MCAL/Mcu")
    mcu_micro_path = mcu_board_path+"/startup/"+gui.uc_info.micro
    paths_mk.write("MCU_STARTUP_PATH := "+mcu_micro_path+"\n")

    mcu_path = search.find_dir("EcuM", cwd+"/submodules")
    paths_mk.write("ECUM_PATH := "+mcu_path+"\n")

    port_path = search.find_dir("Port", cwd+"/submodules")
    paths_mk.write("PORT_PATH := "+port_path+"\n")

    dio_path = search.find_dir("Dio", cwd+"/submodules")
    paths_mk.write("DIO_PATH := "+dio_path+"\n")

    spi_path = search.find_dir("Spi", cwd+"/submodules")
    paths_mk.write("SPI_PATH := "+spi_path+"\n")

    lin_path = search.find_dir("Lin", cwd+"/submodules")
    paths_mk.write("LIN_PATH := "+lin_path+"\n")

    eth_path = search.find_dir("Eth", cwd+"/submodules")
    paths_mk.write("ETH_PATH := "+eth_path+"\n")

    os_path = search.find_dir("Os", cwd+"/submodules")
    paths_mk.write("OS_PATH := "+os_path+"\n")

    os_builder_path = search.find_dir("os_builder", cwd)
    paths_mk.write("OS_BUILDER_PATH := "+os_builder_path+"\n")

    paths_mk.write("\n")

    # Include mk files
    incls_mk.write("# Inclusions\n")
    micro_mk = search.find_file(gui.uc_info.micro+".mk", cwd)
    incls_mk.write("include "+micro_mk+"\n")
    microarch_mk = search.find_file(gui.uc_info.micro_arch+".mk", cwd)
    incls_mk.write("include "+microarch_mk+"\n")
    incls_mk.write("\n")

    # Build a path list for applications to invoke their makefiles
    generate_make_list_for_apps(cwd)
    generate_c_l_flags_file(gui, cwd)

    # ################################################################
    # # Temporary work around. This function needs a redesign
    # app_path = search.find_dir("NammaTestApp", cwd+"/submodules")
    # paths_mk.write("NAMMATESTAPP_PATH := "+app_path+"\n")
    # mk_file = search.find_file_ext("mk", app_path)
    # incls_mk.write("include "+mk_file+"\n")

    # Mcu_mk = search.find_file("Mcu.mk", cwd+"/submodules")
    # incls_mk.write("include "+Mcu_mk+"\n")
    # EcuM_mk = search.find_file("EcuM.mk", cwd+"/submodules")
    # incls_mk.write("include "+EcuM_mk+"\n")
    # Port_mk = search.find_file("Port.mk", cwd+"/submodules")
    # incls_mk.write("include "+Port_mk+"\n")
    # Dio_mk = search.find_file("Dio.mk", cwd+"/submodules")
    # incls_mk.write("include "+Dio_mk+"\n")
    # Spi_mk = search.find_file("Spi.mk", cwd+"/submodules")
    # incls_mk.write("include "+Spi_mk+"\n")
    # Lin_mk = search.find_file("Lin.mk", cwd+"/submodules")
    # incls_mk.write("include "+Lin_mk+"\n")
    # Eth_mk = search.find_file("Eth.mk", cwd+"/submodules")
    # incls_mk.write("include "+Eth_mk+"\n")
    # MacPhy_mk = search.find_file("macphy.mk", cwd+"/submodules")
    # incls_mk.write("include "+MacPhy_mk+"\n")

    # os_objs_mk = search.find_file("os-objs.mk", cwd)
    # incls_mk.write("include "+os_objs_mk+"\n")
    # os_common_mk = search.find_file("os-common.mk", cwd)
    # incls_mk.write("include "+os_common_mk+"\n")
    # common_mk = search.find_file("common.mk", cwd)
    # incls_mk.write("include "+common_mk+"\n")
    # incls_mk.write("\n")
    # # Temporary work around. This function needs a redesign
    # ##################################################################

    # Generate micro & arch specifc header files
    generate_platform_header(gui)
    
    # Update ARXML file
    arxml_mcu.update_arxml(gui.arxml_file, gui.uc_info)
    
    paths_mk.close()
    incls_mk.close()
    
    return 0